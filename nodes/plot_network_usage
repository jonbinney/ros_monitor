#!/usr/bin/env python
PACKAGE_NAME = 'ros_monitor'
import roslib; roslib.load_manifest(PACKAGE_NAME)
import threading
import numpy as np
import matplotlib as mpl
from matplotlib import pyplot as plt
import matplotlib.animation as animation
import rospy

from ros_monitor.msg import RosGraphStats

# graph_data has keys (publisher_ip, publisher_port), and values {'total_bytes':[...], 'topic_name':[...]}
graph_data = {}
graph_data_lock = threading.Lock()

def message_callback(msg):
    global graph_data, graph_data_lock
    rospy.loginfo('Got message')
    with graph_data_lock:
        for connection in msg.connections:
            key = (connection.publisher_ip, connection.publisher_port)
            if not key in graph_data:
                graph_data[key] = {'total_bytes':[], 'topic_name':connection.topic_name, 'times':[]}
            graph_data[key]['total_bytes'].append(connection.total_bytes)

            # this isn't quite correct... should really compute timestamps in the monitor
            # and include them in connection stats -jbinney
            graph_data[key]['times'].append(rospy.Time.now().to_sec())
        

rospy.init_node('network_usage_plotter', anonymous=True)

stats_sub = rospy.Subscriber('/ros_monitor/ros_graph_stats', RosGraphStats, message_callback)

plt.ion()
fig = plt.figure()
ax = fig.add_subplot(111)

loop_rate = rospy.Rate(5)
while not rospy.is_shutdown():
    ax.clear()
    with graph_data_lock:
        for (publisher_ip, publisher_port) in graph_data.keys():
            data = graph_data[(publisher_ip, publisher_port)]
            ax.plot(data['times'], data['total_bytes'], label=data['topic_name'])
    ax.legend()            
    plt.draw()
    loop_rate.sleep()

plt.ioff()
