#!/usr/bin/env python
PACKAGE_NAME = 'ros_monitor'
import roslib; roslib.load_manifest(PACKAGE_NAME)
import threading
import numpy as np
import matplotlib as mpl
from matplotlib import pyplot as plt
import matplotlib.animation as animation
import rospy

from ros_monitor.msg import RosGraphStats


# graph_data has keys (publisher_ip, publisher_port), and values {'total_bytes':[...], 'topic_name':[...]}
graph_data = {}
graph_data_lock = threading.Lock()

def message_callback(msg):
    global graph_data, graph_data_lock
    rospy.loginfo('Got message')
    with graph_data_lock:
        for connection in msg.connections:
            key = (connection.publisher_ip, connection.publisher_port)
            if not key in graph_data:
                graph_data[key] = {'total_bytes':[], 'topic_name':connection.topic_name}
            graph_data[key]['total_bytes'].append(connection.total_bytes)
        

rospy.init_node('network_usage_plotter', anonymous=True)

stats_sub = rospy.Subscriber('/ros_monitor/ros_graph_stats', RosGraphStats, message_callback)

fig = plt.figure()
ax = fig.add_subplot(111)

graph_lines = {}

def animate(i):
    global graph_lines, ax

    x = np.arange(0, 2*np.pi, 0.01)
    line_data = np.sin(x+i/10.0)
    if 'line' in graph_lines:
        graph_lines['line'].set_ydata(line_data)
    else:
        graph_lines['line'], = ax.plot(x, line_data)
        
    return graph_lines['line'],

# Init only required for blitting to give a clean slate.
def init():
    return []

ani = animation.FuncAnimation(fig, animate, init_func=init,
                              interval=25, blit=True)
plt.show()
